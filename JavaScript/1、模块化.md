### 一、什么是模块?

- 将一个复杂的程序依据一定的规则(规范)封装成几个块(文件), 并进行组合在一起
- 块的内部数据与实现是私有的, 只是向外部暴露一些接口(方法)与外部其它模块通信



### 二、模块化的进化过程

- **全局 function 模式 : 将不同的功能封装成不同的全局函数**
  - 编码: 将不同的功能封装成不同的全局函数
  - 问题: 污染全局命名空间, 容易引起命名冲突或数据不安全，而且模块成员之间看不出直接关系

- **namespace 模式 : 简单对象封装**
  - 作用: 减少了全局变量，解决命名冲突
  - 问题: 数据不安全(外部可以直接修改模块内部的数据)

- **IIFE 模式：匿名函数自调用(闭包)**
  - 作用: 数据是私有的, 外部只能通过暴露的方法操作
  - 编码: 将数据和行为封装到一个函数内部, 通过给window添加属性来向外暴露接口
  - 问题: 如果当前这个模块依赖另一个模块怎么办?
- **IIFE模式增强 : 引入依赖**
- **CommonJS**
- **ES Modules**



### 三、模块化规范

- **CommonJS**：同步加载模块
- **AMD**：异步加载模块
  - AMD 推崇依赖前置
  -  AMD 是 requireJS 在推广过程中对模块定义的规范化产出
- **CMD**：用于浏览器端，异步加载模块
  - CMD 推崇依赖就近
  - CMD 是 SeaJS 在推广过程中对模块定义的规范化产出
- **ES Modules**：

#### ES6 模块与 CommonJS 模块的差异

**① CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用**。

**② CommonJS 模块是运行时加载，ES6 模块是编译时输出接口**



### 四、模块化的好处

- 避免命名冲突(减少命名空间污染)
- 更好的分离, 按需加载
- 更高复用性
- 高可维护性



### 五、总结

- CommonJS 规范主要用于服务端编程，加载模块是同步的，这并不适合在浏览器环境，因为同步意味着阻塞加载，浏览器资源是异步加载的，因此有了 AMD CMD 解决方案。
- AMD 规范在浏览器环境中异步加载模块，而且可以并行加载多个模块。不过，AMD 规范开发成本高，代码的阅读和书写比较困难，模块定义方式的语义不顺畅。
- CMD 规范与 AMD 规范很相似，都用于浏览器编程，依赖就近，延迟执行，可以很容易在Node.js中运行。不过，依赖 SPM 打包，模块的加载逻辑偏重
- **ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案**
