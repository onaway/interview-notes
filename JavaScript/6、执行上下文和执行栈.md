### 1、执行上下文

> 执行上下文就是当前 JavaScript 代码被解析和执行时所在环境的抽象概念



### 2、执行上下文的类型

- 全局执行上下文
  - 创建一个全局对象，在浏览器中这个全局对象就是 window 对象
  - 将 this 指针指向这个全局对象，一个程序中只能存在一个全局执行上下文
- 函数执行上下文
  - 每次**调用函数**时，都会为该函数创建一个新的执行上下文
  - 一个程序中可以存在任意数量的函数执行上下文
- Eval 函数执行上下文



### 3、执行上下文的生命周期

执行上下文的生命周期包括三个阶段：**创建阶段 → 执行阶段 → 回收阶段**

#### 3.1、创建阶段

当函数被调用，但未执行任何其内部代码之前，会做以下三件事：

- 创建变量对象
- 创建作用域链
- 确定 this 指向

#### 3.2、执行阶段

> 执行变量赋值、代码执行

#### 3.3、回收阶段

> 执行上下文出栈等待虚拟机回收执行上下文



### 4、变量提升和 this 指向

- 变量声明提升
- 函数声明提升
- 确定 this 的指向：**this 的值是在执行的时候才能确认，定义的时候不能确认**
  - new -> 指向的是构造函数的实例
  - 普通函数 -> 非严格模式（`window`），严格模式（`undefined`）
  - 方法/原型下的 `this` -> 谁调用指向谁
  - 在构造函数模式中，类中(函数体中)出现的 `this.xxx=xxx` 中的 `this` 是当前类的一个实例
  - 箭头函数 -> 指向最近的上下文环境
    - 箭头函数没有自己的 `this`，看其外层的是否有函数，如果有，外层函数的 `this` 就是内部箭头函数的 `this`，如果没有，则 `this` 是 `window`

注意：**当遇到函数和变量同名且都会被提升的情况，函数声明优先级比较高，因此变量声明会被函数声明所覆盖，但是可以重新赋值**



### 5、执行栈

> **是一个存储函数调用的栈结构，遵循先进后出的原则**



执行栈的大致流程：

- JavaScript 执行在单线程上，所有的代码都是排队执行。
- 一开始浏览器执行全局的代码时，首先创建全局的执行上下文，压入执行栈的顶部。
- 每当进入一个函数的执行就会创建函数的执行上下文，并且把它压入执行栈的顶部。当前函数执行完成后，当前函数的执行上下文出栈，并等待垃圾回收。
- 浏览器的 JS 执行引擎总是访问栈顶的执行上下文。
- 全局上下文只有唯一的一个，它在浏览器关闭时出栈