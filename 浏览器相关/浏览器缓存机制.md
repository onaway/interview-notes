## 一、缓存位置，缓存优先级

- Service Worker
- Memory Cache
- Disk Cache
- Push Cache



#### 1、Service Worker

Service Worker 是运行在浏览器背后的独立线程，一般可以用来实现缓存功能。使用 Service Worker 的话，传输协议必须为 HTTPS。**Service Worker 的缓存与浏览器其他内建的缓存机制不同，它可以让我们自由控制缓存哪些文件、如何匹配缓存、如何读取缓存，并且缓存是持续性的**



#### 2、Memory Cache

**Memory Cache 也就是内存中的缓存**，主要包含的是当前中页面中已经抓取到的资源，例如页面上已经下载的样式、脚本、图片等。**一旦我们关闭 Tab 页面，内存中的缓存也就被释放了**



**内存缓存在缓存资源时并不关心返回资源的 HTTP 缓存头 Cache-Control 是什么值，同时资源的匹配也并非仅仅是对 URL 做匹配，还可能会对 Content-Type，CORS 等其他特征做校验**



#### 3、Disk Cache

**Disk Cache 也就是存储在硬盘中的缓存**，读取速度慢点，但是什么都能存储到磁盘中，**比之 Memory Cache 胜在容量和存储时效性上**

Disk Cache 会根据 HTTP Herder 中的字段判断哪些资源需要缓存，哪些资源可以不请求直接使用，哪些资源已经过期需要重新请求

**浏览器会把哪些文件丢进内存中？哪些丢进硬盘中？**

- 对于大文件来说，大概率是不存储在内存中的，反之优先
- 当前系统内存使用率高的话，文件优先存储进硬盘



#### 4、Push Cache

Push Cache（推送缓存）是 HTTP/2 中的内容，当以上三种缓存都没有命中时，它才会被使用。**它只在会话（Session）中存在，一旦会话结束就被释放，并且缓存时间也很短暂**



### 二、缓存过程

- 浏览器每次发起请求，都会先在浏览器缓存中查找该请求的结果以及缓存标识
- 浏览器每次拿到返回的请求结果都会将该结果和缓存标识存入浏览器缓存中



### 三、缓存机制

1. 浏览器发送请求前，根据请求头的 `expires` 和 `cache-control` 判断是否命中（包括是否过期）强缓存策略，如果命中，直接从缓存获取资源，并不会发送请求。如果没有命中，则进入下一步

2. 没有命中强缓存规则，浏览器会发送请求，根据请求头的 `last-modified` 和 `etag` 判断是否命中协商缓存，如果命中，直接从缓存获取资源。如果没有命中，则进入下一步

3. 如果前两步都没有命中，则直接从服务端获取资源

### 四、强缓存和协商缓存

#### 1、强缓存

> 强缓存：不会向服务器发送请求，直接从缓存中读取资源。

当浏览器向服务器发起请求时，服务器会将缓存规则放入 HTTP 响应报文的 HTTP 头中和请求结果一起返回给浏览器，控制强制缓存的字段分别是 `Expires` 和 `Cache-Control`，其中 `Cache-Control` 优先级比 `Expires` 高。

##### Expires

缓存过期时间，用来指定资源到期的时间，是服务器端的具体的时间点。也就是说，`Expires=max-age + 请求时间`，需要和 `Last-modified` 结合使用。`Expires` 是 Web 服务器响应消息头字段，在响应 http 请求时告诉浏览器在过期时间前浏览器可以直接从浏览器缓存取数据，而无需再次请求。

> Expires 是 HTTP/1 的产物，受限于本地时间，如果修改了本地时间，可能会造成缓存失效。

##### Cache-Control

在 HTTP/1.1 中，Cache-Control 是最重要的规则，主要用于控制网页缓存，主要取值为：

- public：所有内容都将被缓存（客户端和代理服务器都可缓存）
- private：所有内容只有客户端可以缓存，Cache-Control 的默认取值
- no-cache：客户端缓存内容，但是是否使用缓存则需要经过协商缓存来验证决定
- no-store：所有内容都不会被缓存，即不使用强制缓存，也不使用协商缓存
- max-age=xxx (xxx is numeric)：缓存内容将在xxx秒后失效

> 需要注意的是，`no-cache` 这个名字有一点误导。设置了 `no-cache` 之后，并不是说浏览器就不再缓存数据，只是浏览器在使用缓存数据时，需要先确认一下数据是否还跟服务器保持一致，也就是协商缓存。而 `no-store` 才表示不会被缓存，即不使用强制缓存，也不使用协商缓存

#### 2、协商缓存

协商缓存就是强制缓存失效后，浏览器携带**缓存标识**向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程

##### Last-modified 和 If-Modified-Since

1. 浏览器首先发送一个请求，让服务端在 `response header` 中返回请求的资源上次更新时间，就是 `last-modified`，浏览器会缓存下这个时间。

2. 然后浏览器再下次请求中，`request header` 中带上 `if-modified-since:[保存的 last-modified 的值]`。根据浏览器发送的修改时间和服务端的修改时间进行比对，一致的话代表资源没有改变，服务端返回正文为空的响应，让浏览器在缓存中读取资源，这就大大减小了请求的消耗。

由于 `last-modified` 依赖的是保存的绝对时间，还是会出现误差的情况：

1. 保存的时间是以秒为单位的，1秒内多次修改是无法捕捉到的；
2. 各机器读取到的时间不一致，就有出现误差的可能性。为了改善这个问题，提出了使用 etag。

##### Etag 和 If-None-Match

`etag` 是 http 协议提供的若干机制中的一种 Web 缓存验证机制，并且允许客户端进行缓存协商。生成 etag 常用的方法包括对资源内容使用抗碰撞散列函数，使用最近修改的时间戳的哈希值，甚至只是一个版本号。 和 last-modified 一样。

- 浏览器会先发送一个请求得到 `etag` 的值，然后下一次请求在 `request header` 中带上 `if-none-match:[保存的 etag 的值]`。
- 通过发送的 `etag` 的值和服务端重新生成的 `etag` 的值进行比对，如果一致代表资源没有改变，服务端返回正文为空的响应，告诉浏览器从缓存中读取资源。

> etag 能够解决 last-modified 的一些缺点，但是 etag 每次服务端生成都需要进行**读写操作**，而 last-modified 只需要**读取操作**，从这方面来看，etag 的消耗是更大的。

二者对比

- 精确度上：Etag 要优于 Last-Modified。
- 优先级上：服务器校验优先考虑 Etag。
- 性能上：Etag 要逊于 Last-Modified

### 五、选择合适的缓存策略

对于大部分的场景都可以使用强缓存配合协商缓存解决，但是在一些特殊的地方可能需要选择特殊的缓存策略

- 对于某些不需要缓存的资源，可以使用 `Cache-control: no-store` ，表示该资源不需要缓存
- 对于频繁变动的资源，可以使用 `Cache-Control: no-cache` 并配合 `ETag` 使用，表示该资源已被缓存，但是每次都会发送请求询问资源是否更新。
- 对于代码文件来说，通常使用 `Cache-Control: max-age=31536000` 并配合策略缓存使用，然后对文件进行指纹处理，一旦文件名变动就会立刻下载新的文件

